importlib user32,\
	EnumChildWindows,\
	MapDialogRect,\
	PostMessageA,\
	GetScrollRange,\
	SetScrollPos
importlib gdi32,\
	CreateSolidBrush,\
	DeleteObject
importlib kernel32,\
	CreateEventA,\
	CloseHandle,\
	CreateThread,\
	Sleep,\
	WaitForMultipleObjects,\
	WaitForSingleObject,\
	SetEvent,\
	ResetEvent,\
	WaitCommEvent,\
	TerminateThread,\
	ExitThread,\
	GetLastError,\
	GetTickCount

proc_noprologue

proc PortForm.switchThread c uses pbx psi, _this
	@virtObj this:arg PortForm at pcx from @arg1

	mov pbx, [this.threadParams.hPauseEvent]
	mov psi, [this.threadParams.hPausedEvent]
	@call [SetEvent](pbx)
	@call [WaitForSingleObject](psi, -1)
	@call [ResetEvent](psi)
	ret
endp

proc PortForm.ThreadProc, lpParam
	@virtObj _params COMReadThreadParams at pbx from @arg1
	locals
		 comIface 	COMIface
		 lastTime 	dptr ?
		 o 			OVERLAPPED
		 flags 		dptr 0
		 dcb 		DCB
		 lpMem		dptr ?
	endl

	mov pax, [_params.hCOM]
	mov [comIface.handle], pax
	mov [comIface.timeouts.ReadIntervalTimeout], 0x7FFFFFFF
	mov [comIface.timeouts.ReadTotalTimeoutMultiplier], 0
	mov [comIface.timeouts.ReadTotalTimeoutConstant], 0
	@call comIface->setTimeouts()
	@call comIface->setMask(EV_RXCHAR or EV_TXEMPTY)
	@call comIface->reset()
	mov eax, [_params.sizeBuf]
	@call [lpMem] = CNV::alloc(addr pax * 2 + 4)
	@call [lastTime] = [GetTickCount]()
	mov pax, [_params.hCOMEvent]
	mov [o.hEvent], pax
	lea psi, [flags]
	lea pdi, [o]
	.read_loop:
		@call comIface->waitEvent(psi, pdi)
		@call [WaitForMultipleObjects](3, addr _params._events, 0, [_params.delay])
		switch eax
			case WAIT_OBJECT_0
				; @call c [puts]("exit")
				@call comIface->setMask(0)
				@call CNV::free([lpMem])
				@call [ExitThread](0)
			case WAIT_OBJECT_0 + 1
				; @call c [puts]("pause")
				@call [ResetEvent]([_params.hPauseEvent])
				@call [SetEvent]([_params.hPausedEvent])
				@call [WaitForSingleObject]([_params.hPauseEvent], -1)
				@call [ResetEvent]([_params.hPauseEvent])
				@call [SetEvent]([_params.hPausedEvent])
				@call comIface->reset()
				mov eax, [_params.sizeBuf]
				@call CNV::realloc([lpMem], addr pax * 2 + 4)
				mov [lpMem], pax
				mov dword[pax], 0
				; @call c [puts]("resume")
				jmp .read_loop
			case WAIT_OBJECT_0 + 2
				; @call c [puts]("input")
				@call comIface->getStat()
				test eax, eax
				jnz .no_err
					@call CNV::free([lpMem])
					@call comIface->setMask(0)
					@call [PostMessageA]([_params.hWnd], PortForm.WM_COMM, NULL, 0)
					@call [ExitThread](0)
				.no_err:
				cmp [comIface.comstat.cbInQue], 0
					je .read_loop
				mov edi, [comIface.comstat.cbInQue]
				mov psi, [lpMem]
				mov eax, dword[psi]
				@call comIface->read(addr psi + pax + 4, pdi, addr o)
				@call [WaitForSingleObject]([o.hEvent], -1)
				@call pdi = comIface->getReadedCount(addr o)
				add edi, dword[psi]
				mov dword[psi], edi
				shr edi, 1
				cmp edi, [_params.sizeBuf]
				jae .overflow_buf
					lea psi, [flags]
					lea pdi, [o]
					@call [GetTickCount]()
					sub eax, dword[lastTime]
					cmp eax, [_params.delay]
						jb .read_loop
				.overflow_buf:
			case WAIT_TIMEOUT
				@call [lastTime] = [GetTickCount]()
				mov pax, [lpMem]
				cmp dword[pax], 0
					je .read_loop
				mov psi, pax
				@call [PostMessageA]([_params.hWnd], PortForm.WM_COMM, psi, dword[psi])
				mov eax, [_params.sizeBuf]
				@call [lpMem] = CNV::alloc(addr pax * 2 + 4)
				lea psi, [flags]
				jmp .read_loop
			; case_default
			; 	@call c [printf]("%d", eax)
		end_switch
	jmp .read_loop
endp

proc PortForm_init uses pbx psi, lpForm, lpParams, lpEventData
	@virtObj form:arg PortForm at pbx from @arg1
	@virtObj parent:arg ColoredDialog at psi from [form.lpParent]

	; open COM
	@call form.comIface->openA(addr form.portName)
	test pax, pax
	jnz .noErr
		@call WND::msgBox("Ошибка открытия порта", NULL, MB_OK, [form.hWnd])
		@call form->close()
		ret
	.noErr:

	; base form settings
	@call form->setIcon([parent.hIcon])
	@call form->setCornerType(DWMWCP.DONOTROUND)
	@call form->setText(addr form.portName)
	@call form.tListBox->addItem("ASCII")
	@call form.tListBox->addItem("HEX")

	; theme settings
	@call form->setCaptionColor([parent.backColor])
	@call [EnumChildWindows](\
		[form.hWnd], ChangeThemeChilds,\
		ColoredDialog.DarkThemes\
	)

	; min/max size settings
	@call [MapDialogRect]([form.hWnd], addr form.minMaxRect)
	cmp [form.minMaxRect.right], 0
	jg @f
		mov [form.minMaxRect.right], 0x7FFFFFFF
	@@:
	cmp [form.minMaxRect.bottom], 0
	jg @f
		mov [form.minMaxRect.bottom], 0x7FFFFFFF
	@@:

	; COMIface settings and delay set
	local dcb:DCB
	@call form.comIface->getParams(addr dcb)
	mov [dcb.BaudRate], 9600
	; mov [form.threadParams.delay], 1000 / 50
	@call form.comIface->setParams(addr dcb)

	; comboBaud values set
	.BaudValues @const dq "75", "110", "134", "150", "300", "600", "1200", \
			"1800", "2400", "4800", "7200", "9600", "14400", "19200", \
			"38400", "57600", "115200", "128000"
	mov psi, -.BaudValues.len
	@@:
		@call form.comboBaud->addItem(addr .BaudValues + .BaudValues.len + psi)
	add psi, 8
	jnz @b
	@call form.comboBaud->setSelected(11)

	; comboByteSize values set
	local bszNums:dd "4"
	@@:
		@call form.comboByteSize->addItem(addr bszNums)
		inc [bszNums]
	cmp [bszNums], "8"
	jle @b
	movzx pax, [dcb.ByteSize]
	@call form.comboByteSize->setSelected(addr pax - 4)

	; comboParity
	.ParityValues @const dq "Нет", "Нечет", "Чёт", "Маркер", "Пробел"
	mov psi, -.ParityValues.len
	@@:
		@call form.comboParity->addItem(addr .ParityValues + .ParityValues.len + psi)
	add psi, 8
	jnz @b
	@call form.comboParity->setSelected([dcb.Parity])

	; comboStopBits
	.StopBitsValues @const dd "1", "1.5", "2"
	mov psi, -.StopBitsValues.len
	@@:
		@call form.comboStopBits->addItem(addr .StopBitsValues + .StopBitsValues.len + psi)
	add psi, 4
	jnz @b
	@call form.comboStopBits->setSelected([dcb.StopBits])

	; setup editIn
	@call form.editIn->setLimit(EDIT.LIMIT_TEXT)

	; string buffer init
	@call form.strBuf->make(0)

	; run thread for read from port
	mov pax, [form.hWnd]
	mov [form.threadParams.hWnd], pax
	mov pax, [form.comIface.handle]
	mov [form.threadParams.hCOM], pax
	@call [CreateEventA](NULL, 1, 0, NULL)
	mov [form.overlapped.hEvent], pax
	mov [form.threadParams.hCOMEvent], pax
	@call [form.threadParams.hStopEvent] = [CreateEventA](NULL, 1, 0, NULL)
	@call [form.threadParams.hPauseEvent] = [CreateEventA](NULL, 1, 0, NULL)
	@call [form.threadParams.hPausedEvent] = [CreateEventA](NULL, 1, 0, NULL)
	mov [form.threadParams.delay], PortForm.UPDATE_DELAY
	mov [form.threadParams.sizeBuf], PortForm.COM_BUF_SIZE
	@call [form.hThread] = [CreateThread](NULL, NULL, PortForm.ThreadProc, addr form.threadParams, 0, 0)
	
	; stopped by default
	@call form->switchThread()

	@call [form.hDeviceNotify] = COMInfo::registerNotify([form.hWnd], DEVICE_NOTIFY_WINDOW_HANDLE)
	mov [form.isPaused], 1
	mov eax, esp
	ret
endp

proc PortForm.PauseButton_click uses pbx, lpForm, lpParams, lpControl, lpEventData
	@virtObj form:arg PortForm at pbx from @arg1
	.buttonOpenTexts @const dq "Пауза", "Пуск"
	xor [form.isPaused], 1
	@call form->switchThread()
	mov eax, [form.isPaused]
	@call form.buttonPause->setText(addr .buttonOpenTexts + pax * 8)
	ret
endp

proc PortForm.ClearButton_click, lpForm, lpParams, lpControl, lpEventData
	@virtObj form:arg PortForm at pcx from @arg1
	@call form.editIn->setText("")
	ret
endp

proc PortForm.SendButton_click uses pbx, lpForm, lpParams, lpControl, lpEventData
	@virtObj form:arg PortForm at pbx from @arg1
	@call form.editOut->getString(addr form.strBuf)
	@call form.strBuf->getLpChars()
	@call form.comIface->write(pax, [form.strBuf.len], addr form.overlapped)
	@call [WaitForSingleObject]([form.overlapped.hEvent], -1)
	ret
endp

proc PortForm.SetupButton_clicked uses pbx psi, lpForm, lpParams, lpControl, lpEventData
	.BaudValues @const dd 75, 110, 134, 150, 300, 600, 1200, \
			1800, 2400, 4800, 7200, 9600, 14400, 19200, \
			38400, 57600, 115200, 128000
	@virtObj form:arg PortForm at pbx from @arg1
	local dcb:DCB, retAddr:POINTER
	
	mov [retAddr], .after_pause_1
	test [form.isPaused], 1
		jz .pause
	.after_pause_1:

	; setup COMIface
	@call form.comIface->getParams(addr dcb)
	@call form.comboBaud->getSelected()
	mov eax, [.BaudValues + pax * 4]
	mov [dcb.BaudRate], eax
	@call form.comboParity->getSelected()
	mov [dcb.Parity], al
	@call form.comboByteSize->getSelected()
	add al, 4
	mov [dcb.ByteSize], al
	@call form.comboStopBits->getSelected()
	mov [dcb.StopBits], al
	@call form.editDelay->getString(addr form.strBuf)
	@call form.strBuf->parseInt(10)

	.delayError @const db "Слишком низкая задержка! Не менее 10 мс.", 0
	mov pdx, .delayError
	cmp eax, 10
		jb .error
	
	mov [form.threadParams.delay], eax
	@call form.editBufSize->getString(addr form.strBuf)
	@call form.strBuf->parseInt(10)

	.sizeError @const db "Недопустимый размер буфера! От 512 до 65 536 байт.", 0
	mov pdx, .sizeError
	cmp eax, 512
		jb .error
	cmp eax, 65536
		ja .error

	mov [form.threadParams.sizeBuf], eax
	@call form.comIface->setParams(addr dcb)

	mov [retAddr], .after_pause_2
	test [form.isPaused], 1
		jz .pause
	.after_pause_2:
	ret

	.pause:
		@call form->switchThread()
		jmp [retAddr]

	.error:
		@call WND::msgBox(pdx)
		ret
endp

; proc PortForm.asciiToHex uses psi pdi, lpMem, lpSize
; 	@sarg @arg1, @arg2
; 	@larg psi, @arg1

; 	local lpDest:POINTER
; 	mov ecx, dword[psi]
; 	@call pdi = CNV::alloc(addr pcx * 3 + 4)
; 	mov [lpDest], pdi
; 	mov ecx, dword[psi]
	
; 	lea pax, [pcx * 3]
; 	mov dword[pdi], eax

; 	mov pdx, [lpSize]
; 	mov dword[pdx], eax
	
; 	add psi, 4
; 	add pdi, 4
; 	; mov pbx, pcx

; 	.convert_loop:
; 		xor eax, eax
; 		lodsb
; 		mov edx, eax


; 		and eax, 0xF
; 		shl eax, 8
; 		cmp eax, 0x900
; 		jbe @f
; 			add eax, (0x4000 - 0x3900)
; 		@@:

; 		shr edx, 4
; 		and edx, 0xF
; 		cmp edx, 0x9
; 		jbe @f
; 			add edx, (0x40 - 0x39)
; 		@@:
; 		lea eax, [eax + edx + 0x200000 + 0x3030]
; 		stosd
; 		dec pdi
; 	loop .convert_loop

; 	@call CNV::free([lpMem])
; 	mov pax, [lpDest]
; 	ret
; endp

proc PortForm_COMIn uses pbx psi, lpForm, lpParams, lpEventData
	@virtObj form:arg PortForm at pbx from @arg1
	@virtObj _params:arg params at psi from @arg2
	locals
		textLen 	dd ?
		startSel 	dd ?
		endSel 		dd ?
	endl
	cmp [_params.wParam], NULL
	jne .noError
		@call form->close()
		ret
	.noError:
	; @call c [printf]("%d\n", [_params.lParam])
	test [form.isPaused], 1
	jnz .noAdd
		; @call [_params.wParam] = PortForm.asciiToHex([_params.wParam], addr _params.lParam)
		; @call PortForm.asciiToHex([_params.wParam], [_params.lParam])
		@call form.editIn->setRedraw(0)
		@call form.editIn->getSelected(addr startSel, addr endSel)
		@call form.editIn->getTextLen()
		mov [textLen], eax
		add pax, [_params.lParam]
		cmp eax, EDIT.LIMIT_TEXT
		js @f
			shr eax, 2
			sub [textLen], eax
			sub [startSel], eax
			sub [endSel], eax
			@call form.editIn->setSelected(0, eax)
			@call form.editIn->replaceSelected("")
		@@:
		; @call c [printf]("%d\n", eax)
		@call form.editIn->setSelected([textLen], [textLen])
		@call form.editIn->setRedraw(1)
		mov pax, [_params.wParam]
		@call form.editIn->replaceSelected(addr pax + 4)
		cmp [startSel], 0
		jl .breakBounds
			@call form.editIn->setSelected([startSel], [endSel])
		.breakBounds:
		; @call [GetScrollRange]([form.editIn.hWnd], addr startSel, addr endSel)
		@call form.editIn->invalidate()
		; @call [SetScrollPos]([form.editIn.hWnd], SB_VERT, [endSel], 1)
	.noAdd:
	@call CNV::free([_params.wParam])
	ret
endp

proc PortForm_deviceChange uses pbx, lpForm, lpParams, lpEventData
	@virtObj form:arg PortForm at pbx from @arg1
	@call form.comIface->getStat()
	test pax, pax
		jnz .return
	@call form->close()
	.return: ret
endp

proc PortForm_ctlColor, lpForm, lpParams, lpEventData
	@virtObj form:arg PortForm at pcx from @arg1
	@virtObj parent:arg ColoredDialog at pcx from [form.lpParent]
	@call ColoredDialog_ctlColor(addr parent, @arg2, @arg3)
	ret
endp

proc PortForm_paintGroup, lpForm, lpParams, lpControl, lpEventData
	@virtObj form:arg PortForm at pcx from @arg1
	@virtObj parent:arg ColoredDialog at pcx from [form.lpParent]
	@call ColoredDialog_paintGroup(addr parent, @arg2, @arg3, @arg4)
	ret
endp

proc PortForm_close uses pbx, lpForm, lpParams, lpEventData
	@virtObj form:arg PortForm at pbx from @arg1
	@call COMInfo::unregisterNotify([form.hDeviceNotify])
	@call form.strBuf->unmake()
	test [form.isPaused], 1
	jz .no_paused
		@call form->switchThread()
	.no_paused:
	@call [SetEvent]([form.threadParams.hStopEvent])
	; @call c [puts]("prepare to stop")
	@call [WaitForSingleObject]([form.hThread], -1)
	@call [CloseHandle]([form.hThread])
	@call [CloseHandle]([form.threadParams.hCOMEvent])
	@call [CloseHandle]([form.threadParams.hStopEvent])
	@call [CloseHandle]([form.threadParams.hPauseEvent])
	@call [CloseHandle]([form.threadParams.hPausedEvent])
	@call form.comIface->close()
	ret
endp

proc_resprologue
